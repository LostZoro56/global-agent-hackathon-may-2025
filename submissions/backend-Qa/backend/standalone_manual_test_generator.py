import os
import re
import csv
import random
import string
import time
import pandas as pd
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class StandaloneManualTestGenerator:
    """
    Standalone Manual Test Case Generator that doesn't rely on the Agno library
    This can be used independently of the main backend infrastructure
    """
    
    def __init__(self):
        """Initialize the Standalone Manual Test Generator"""
        # Create base directories
        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.test_cases_dir = os.path.join(self.base_dir, 'test_cases')
        os.makedirs(self.test_cases_dir, exist_ok=True)
        
        # Sample test cases for demonstration (these would normally be generated by an LLM)
        self.sample_test_cases = [
            {
                'Test Case ID': 'TC001',
                'Description': 'Verify login with valid credentials',
                'Test Steps': '1. Navigate to login page\n2. Enter username\n3. Enter password\n4. Click login button',
                'Test Data Set 1': 'Username: user1, Password: pass123',
                'Test Data Set 2': 'Username: admin, Password: admin123',
                'Test Data Set 3': 'Username: test_user, Password: Test@123',
                'Test Data Set 4': 'Username: john.doe, Password: J0hn#2023',
                'Test Data Set 5': 'Username: guest_user, Password: Guest!456',
                'Expected Result': 'User should be successfully logged in and redirected to dashboard'
            },
            {
                'Test Case ID': 'TC002',
                'Description': 'Verify login with invalid credentials',
                'Test Steps': '1. Navigate to login page\n2. Enter invalid username\n3. Enter invalid password\n4. Click login button',
                'Test Data Set 1': 'Username: invalid_user, Password: wrong_pass',
                'Test Data Set 2': 'Username: user1, Password: wrong_pass',
                'Test Data Set 3': 'Username: invalid_user, Password: pass123',
                'Test Data Set 4': 'Username: !@#$%, Password: 12345',
                'Test Data Set 5': 'Username: <empty>, Password: <empty>',
                'Expected Result': 'Error message should be displayed: "Invalid username or password"'
            },
            {
                'Test Case ID': 'TC003',
                'Description': 'Verify password reset functionality',
                'Test Steps': '1. Navigate to login page\n2. Click "Forgot Password" link\n3. Enter email address\n4. Click "Reset Password" button',
                'Test Data Set 1': 'Email: user1@example.com',
                'Test Data Set 2': 'Email: admin@company.com',
                'Test Data Set 3': 'Email: test@test.org',
                'Test Data Set 4': 'Email: john.doe@gmail.com',
                'Test Data Set 5': 'Email: invalid_email',
                'Expected Result': 'Password reset email should be sent for valid email addresses, error message for invalid ones'
            }
        ]
    
    def generate_test_cases(self, user_story):
        """
        Generate test cases based on user story
        In a real implementation, this would call an LLM
        For this standalone version, we'll generate test cases based on keywords
        """
        print(f"Generating test cases for: {user_story}")
        
        # In a real implementation, we would process the user story and generate relevant test cases
        # For this standalone version, we'll just return sample test cases with some customization
        
        test_cases = []
        
        # Extract keywords from user story
        keywords = re.findall(r'\b\w{4,}\b', user_story.lower())
        unique_keywords = list(set(keywords))
        
        # Generate test cases based on keywords
        for i, keyword in enumerate(unique_keywords[:5]):  # Limit to 5 test cases
            # Create a new test case based on the template
            test_case = self.sample_test_cases[i % len(self.sample_test_cases)].copy()
            
            # Customize the test case based on the keyword
            test_case['Test Case ID'] = f'TC{(i+1):03d}'
            test_case['Description'] = f'Verify {keyword} functionality'
            
            # Add the test case to the list
            test_cases.append(test_case)
            
            # If we have enough test cases, stop
            if len(test_cases) >= 5:
                break
                
        # If no test cases were generated, use the sample test cases
        if not test_cases:
            test_cases = self.sample_test_cases
            
        return test_cases
    
    def generate_data_variations(self, data_point):
        """
        Generate variations of a test data point for multiple test data sets
        Returns a list of 4 variations of the original data point
        """
        variations = []
        
        # Variation 1: Change numeric values if present
        var1 = re.sub(r'\b\d+\b', lambda m: str(int(m.group(0)) + random.randint(1, 10)), data_point)
        variations.append(var1)
        
        # Variation 2: Change string case or add a prefix
        if any(c.isalpha() for c in data_point):
            if data_point.islower():
                var2 = data_point.title()
            elif data_point.isupper():
                var2 = data_point.lower()
            else:
                var2 = "Alt_" + data_point
            variations.append(var2)
        else:
            # If no alphabetic characters, add a random suffix
            var2 = data_point + "_v2"
            variations.append(var2)
        
        # Variation 3: Add a random character to strings or modify numbers
        random_char = random.choice(string.ascii_letters)
        if any(c.isdigit() for c in data_point):
            var3 = re.sub(r'\b\d+\b', lambda m: str(int(m.group(0)) * 2), data_point)
        else:
            var3 = data_point + random_char
        variations.append(var3)
        
        # Variation 4: Combine approaches or create a more distinct variation
        if 'valid' in data_point.lower():
            var4 = data_point.replace('valid', 'invalid').replace('Valid', 'Invalid')
        elif 'true' in data_point.lower():
            var4 = data_point.replace('true', 'false').replace('True', 'False')
        elif 'yes' in data_point.lower():
            var4 = data_point.replace('yes', 'no').replace('Yes', 'No')
        else:
            var4 = "Test_" + data_point
        variations.append(var4)
        
        return variations
    
    def enhance_test_cases(self, test_cases):
        """
        Enhance test cases with additional data variations
        """
        enhanced_test_cases = []
        
        for tc in test_cases:
            # Create a copy of the test case
            enhanced_tc = tc.copy()
            
            # If Test Data Set 1 exists but other sets don't, generate variations
            if 'Test Data Set 1' in enhanced_tc and enhanced_tc['Test Data Set 1']:
                data_points = enhanced_tc['Test Data Set 1'].split('\n')
                
                # Process each data point
                for i in range(2, 6):  # Sets 2-5
                    set_key = f'Test Data Set {i}'
                    if set_key not in enhanced_tc or not enhanced_tc[set_key]:
                        # Generate variations for this set
                        variations = []
                        for dp in data_points:
                            if dp.strip():
                                # Get the variation for this data point
                                var_idx = i - 2  # 0-3 for sets 2-5
                                all_vars = self.generate_data_variations(dp)
                                variation = all_vars[var_idx % len(all_vars)]
                                variations.append(variation)
                        
                        # Join the variations
                        enhanced_tc[set_key] = '\n'.join(variations)
            
            enhanced_test_cases.append(enhanced_tc)
            
        return enhanced_test_cases
    
    def save_to_csv(self, test_cases, output_file):
        """
        Save test cases to a CSV file
        """
        # Ensure directory exists
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        
        # Define field names
        fieldnames = [
            'Test Case ID', 'Description', 'Test Steps',
            'Test Data Set 1', 'Test Data Set 2', 'Test Data Set 3',
            'Test Data Set 4', 'Test Data Set 5', 'Expected Result'
        ]
        
        # Write to CSV
        try:
            with open(output_file, 'w', newline='') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                for test_case in test_cases:
                    writer.writerow(test_case)
                    
            print(f"Test cases successfully written to {output_file}")
            return output_file
            
        except Exception as e:
            print(f"Error writing to CSV file: {str(e)}")
            # Try writing to a different location
            alt_output_file = os.path.join(os.getcwd(), os.path.basename(output_file))
            
            with open(alt_output_file, 'w', newline='') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                for test_case in test_cases:
                    writer.writerow(test_case)
                    
            print(f"Test cases written to alternate location: {alt_output_file}")
            return alt_output_file
    
    def generate_from_user_story(self, user_story):
        """
        Generate test cases from a user story
        
        Args:
            user_story: The user story to generate test cases from
            
        Returns:
            Dictionary with generation results
        """
        try:
            # Generate a feature name from the user story
            feature_name = self._generate_feature_name(user_story)
            
            # Generate test cases
            test_cases = self.generate_test_cases(user_story)
            
            # Enhance test cases with data variations
            enhanced_test_cases = self.enhance_test_cases(test_cases)
            
            # Save to CSV
            output_file = os.path.join(self.test_cases_dir, f"{feature_name}.csv")
            saved_file = self.save_to_csv(enhanced_test_cases, output_file)
            
            return {
                'status': 'success',
                'test_cases': enhanced_test_cases,
                'filename': os.path.basename(saved_file),
                'file_path': saved_file,
                'count': len(enhanced_test_cases),
                'message': 'Test cases generated successfully'
            }
            
        except Exception as e:
            print(f"Error: {str(e)}")
            return {
                'status': 'error',
                'message': f"Error generating test cases: {str(e)}",
                'test_cases': [],
                'filename': '',
                'file_path': '',
                'count': 0
            }
    
    def _generate_feature_name(self, user_story):
        """
        Generate a sanitized feature name from the user story
        """
        # Extract key words from the user story
        words = re.findall(r'\b[A-Za-z]{3,}\b', user_story)
        
        # Use the first few words to create a feature name
        if words:
            name_words = words[:3]
            feature_name = '_'.join(name_words).lower()
        else:
            # Fallback to timestamp
            feature_name = f"test_cases_{int(time.time())}"
            
        # Sanitize the name
        feature_name = re.sub(r'[^a-z0-9_]', '', feature_name)
        
        # Ensure it's not too long
        if len(feature_name) > 50:
            feature_name = feature_name[:50]
            
        return feature_name

def main():
    """
    Command-line interface for the Standalone Manual Test Generator
    """
    try:
        print("=" * 50)
        print("Manual Test Case Generator")
        print("=" * 50)
        
        # Get input from user
        prompt = input("Enter your requirement or user story: ")
        
        if not prompt:
            print("Error: No requirement provided")
            return
            
        # Initialize the generator
        generator = StandaloneManualTestGenerator()
        
        # Generate test cases
        print("\nGenerating manual test cases...")
        start_time = time.time()
        
        result = generator.generate_from_user_story(prompt)
        
        end_time = time.time()
        
        if result['status'] == 'success':
            print(f"\nGeneration completed in {end_time - start_time:.2f} seconds")
            print(f"Generated {result['count']} test cases")
            print(f"Saved to: {result['file_path']}")
            
            # Display the first test case as a sample
            if result['test_cases'] and len(result['test_cases']) > 0:
                print("\nSample test case:")
                print("-" * 50)
                tc = result['test_cases'][0]
                print(f"Test Case ID: {tc.get('Test Case ID', 'Unknown')}")
                print(f"Description: {tc.get('Description', 'No description')}")
                print(f"Test Steps:\n{tc.get('Test Steps', 'No steps')}")
                print(f"Test Data Set 1:\n{tc.get('Test Data Set 1', 'No data')}")
                print(f"Expected Result:\n{tc.get('Expected Result', 'No expected result')}")
                
                print("\nAll test cases have been saved to the CSV file.")
        else:
            print(f"\nError: {result.get('message', 'Unknown error')}")
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
    except Exception as e:
        print(f"\nError: {str(e)}")

if __name__ == "__main__":
    main()
